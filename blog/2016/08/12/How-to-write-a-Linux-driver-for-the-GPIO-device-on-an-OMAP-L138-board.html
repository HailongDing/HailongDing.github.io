<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Hailong Ding :: How to write a Linux driver for the GPIO device on an OMAP-L138 board</title>
    <meta name="description" content="“TI’s OMAP-L138 processor is a low-power applications processor based on an ARM926EJ-S and a C674x DSP core”. It provides significantly low power and has bee...">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://localhost:4000/blog/2016/08/12/How-to-write-a-Linux-driver-for-the-GPIO-device-on-an-OMAP-L138-board">
    <link rel="alternate" type="application/rss+xml" title="Hailong Ding" href="http://localhost:4000/feed.xml" />

    <link href='https://fonts.googleapis.com/css?family=EB+Garamond' rel='stylesheet' type='text/css'>
</head>


  <body>
  <div class="page">
    <header class="site-header">
    <a class="site-title" href="/">Hailong Ding</a>
    <nav class="site-nav">
        <a href="#" class="menu-icon menu.open">
            <svg viewBox="0 0 18 15">
                <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
        </a>
        <div class="trigger"><h1>Main Navigation</h1>
            <ul class="menu">
    
    
     <li><a href="/blog/" class="page-link">Blog</a>
    
    </li>
    
    
     <li><a href="/misc/" class="page-link">Misc</a>
    
    </li>
    
</ul>

        </div>
    </nav>
</header>


    <div class="post">
    <header class="post-header">
    <h1>How to write a Linux driver for the GPIO device on an OMAP-L138 board</h1>
    <p class="post-meta">Posted on August 12, 2016  ()</p>

    

    
    <p class="post-meta">Categories:
    
    <!-- <a href=" | prepend: site.baseurl}}" title="linux driver">linux driver</a>&nbsp; -->
    linux driver&nbsp;
    
    <!-- <a href=" | prepend: site.baseurl}}" title="OMAP-L138">OMAP-L138</a>&nbsp; -->
    OMAP-L138&nbsp;
    

    </p>
    
    </header>

    <p>“TI’s OMAP-L138 processor is a low-power applications processor based on an ARM926EJ-S and a C674x DSP core”. It provides significantly low power and has been widely used in the industry. In this article I will show you how to write a Linux driver for the GPIO device on a board based on this processor. We will use the AD5420 DAC (Digital to Analog) converter for this demonstration.</p>

<p>Before writing any code, let’s learn something about the hardware background. As we can see from the datasheet of AD5420, to make it work, all we need to do is to control the three special pins (suppose all pins have been connected correctly), labeled as LATCH, SCLK, and SDIN. As we all know, the GPIO peripheral provides general-purpose pins that can be configured as either inputs or outputs. The OMAP-L138 processor has up to 9 banks of GPIO pins, with each bank containing 16 pins. In this project, we used the 3nd bank of pins to connect with the DAC converter. They are GPIO2_10, GPIO2_11, and GPIO2_12 respectively.</p>

<p>First of all, we have to configure the PINMUX. The OMAP-L138 development kit has already provided an example. We just need to modify two files. In the file “/mach-davinci/include/mach/mux.h”, we will add DA850_GPIO2_10, DA850_GPIO2_11, and DA850_GPIO2_12 to the “enum davinci_da850_index” section. And in the file “arch/arm/mach-davinci/da850.c”, we add the following codes:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>    <span class="n">MUX_CFG</span><span class="p">(</span><span class="n">DA850</span><span class="p">,</span> <span class="n">GPIO2_10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="c1">// connected with SCLK
</span>    <span class="n">MUX_CFG</span><span class="p">(</span><span class="n">DA850</span><span class="p">,</span> <span class="n">GPIO2_11</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="c1">// connected with LATCH
</span>    <span class="n">MUX_CFG</span><span class="p">(</span><span class="n">DA850</span><span class="p">,</span> <span class="n">GPIO2_12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">//</span> <span class="n">connected</span> <span class="n">with</span> <span class="n">SDIN</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The format of the MUX_CFG is (for a thorough understanding, we can check the processor’s technical reference manual):</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>    <span class="n">DA850</span> <span class="o">-&gt;</span> <span class="n">SOC</span> <span class="n">name</span>
    <span class="n">GPIO2_10</span> <span class="o">-&gt;</span> <span class="n">Pin</span> <span class="n">desc</span>
    <span class="mi">5</span> <span class="o">-&gt;</span> <span class="n">PINMUX5</span>
    <span class="mi">20</span> <span class="o">-&gt;</span> <span class="n">Offset</span> <span class="n">value</span> <span class="n">of</span> <span class="n">PINMUX5</span>
    <span class="mi">15</span> <span class="o">-&gt;</span> <span class="n">Mask</span> <span class="k">default</span> <span class="n">value</span>
    <span class="mi">8</span> <span class="o">-&gt;</span> <span class="n">Mode</span>
    <span class="nb">false</span> <span class="o">-&gt;</span> <span class="k">for</span> <span class="n">debugging</span> <span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>We also need to check that the GPIO driver is enabled in the Linux kernel. Then we rebuild the kernel.</p>

<p>Here we can write the actual device drive. A Linux drive consists of three main operations, there are “ioctl”, “read”, and “write”. And we also should implement the “init_module” and “cleanup_module” functions. And we’d better provide the statement of “MODULE_LICENSE”, ” MODULE_DESCRIPTION ” and “MODULE_AUTHOR” at the end of the source code. The following is the complete source code. Some comments have been added to make it readable.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266</pre></td><td class="code"><pre><span class="cm">/* 
 *  Linux driver for AD5420
 * 
 *  12-Bit, Serial Input, 4 mA to 20 mA   
 * 
 *  The system contains 6 devices, so we will use the daisy-chain mode
 *
 */</span>
 
<span class="cp">#include &lt;linux/module.h&gt;
#include &lt;linux/version.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/completion.h&gt;
#include &lt;mach/cputype.h&gt;
#include &lt;mach/hardware.h&gt;
#include &lt;mach/mux.h&gt;
#include &lt;asm/gpio.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;linux/fs.h&gt;
</span> 
<span class="cp">#define  DEVICE_NAME      "/dev/myAD5420"   // the name of the device
#define  DEVICE_MAJOR     253    // major number of the device
#define  MAX_DEVICE_NUM   6      // 6 AD5420 chips in the daisy-chain mode
#define  SCLK_PIN         42     // connected to GPIO 2[10]
#define  LATCH_PIN        43     // connected to GPIO 2[11]
#define  SDIN_PIN         44     // connected to GPIO 2[12]
#define  CMD_BIT_NUM      8      // 8 bits
#define  DATA_BIT_NUM     16     // 16 bits    
#define  TOTAL_PIN_NUM    3      // 3 pins used
</span> 
<span class="k">static</span> <span class="kt">int</span>          <span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">TOTAL_PIN_NUM</span><span class="p">]</span>  <span class="o">=</span>   <span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">44</span><span class="p">};</span>
                                  <span class="c1">// 2*16 + 10, 2*16 + 11, 2*16 + 12
</span> 
<span class="k">struct</span>  <span class="n">data_unit</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">device_index</span><span class="p">;</span>       <span class="c1">// between [0,MAX_DEVICE_NUM-1]
</span>    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">out_value</span><span class="p">;</span>          <span class="c1">// 12 bits valid
</span><span class="p">};</span>
 
<span class="k">static</span>  <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">global_value_array</span><span class="p">[</span><span class="n">MAX_DEVICE_NUM</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ad5420_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">ad5420_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">ad5420_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
 
<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">ioctl</span><span class="o">:</span> <span class="n">ad5420_ioctl</span><span class="p">,</span>
    <span class="n">read</span><span class="o">:</span>  <span class="n">ad5420_read</span><span class="p">,</span>
    <span class="n">write</span><span class="o">:</span> <span class="n">ad5420_write</span>
<span class="p">};</span>
 
<span class="kt">void</span>   <span class="n">InitDevice</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>        
<span class="kt">void</span>   <span class="n">WriteUnit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_value</span><span class="p">);</span>
<span class="kt">void</span>   <span class="n">ShiftCommand</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">);</span>
<span class="kt">void</span>   <span class="n">ShiftData</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span>   <span class="n">OutPutData</span><span class="p">();</span>
 
<span class="kt">int</span> <span class="nf">init_module</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">status</span><span class="p">,</span><span class="n">major</span><span class="p">;</span>
 
    <span class="c1">// configure the pins
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_PIN_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">davinci_cfg_reg</span><span class="p">(</span><span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printk</span><span class="p">(</span><span class="s">"Pin could not be muxed for GPIO functionality %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                       <span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>  <span class="c1">// in the driver we use printk
</span>            <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="c1">// request GPIO resource
</span>    <span class="kt">char</span> <span class="n">gpio_pin_name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_PIN_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sprintf</span><span class="p">(</span><span class="n">gpio_pin_name</span><span class="p">,</span> <span class="s">"gpio_%d"</span><span class="p">,</span> <span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gpio_pin_name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printk</span><span class="p">(</span><span class="s">"Can not open GPIO %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="c1">// set GPIO's input/output directions
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_PIN_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>
 
    <span class="c1">// set initial values
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_PIN_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>
 
    <span class="n">InitDevice</span><span class="p">();</span>
 
    <span class="c1">// register the device
</span>    <span class="n">major</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="n">DEVICE_MAJOR</span><span class="p">,</span> <span class="n">DEVICE_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fops</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span> <span class="p">(</span><span class="s">"Registering the character device failed with %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">major</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">major</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="c1">// clean the global value array
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_PIN_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">global_value_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 
    <span class="c1">// release GPIO resource
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_PIN_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">gpio_free</span><span class="p">(</span><span class="n">GPIO_PIN_NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
 
    <span class="c1">// unregister the device
</span>    <span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">DEVICE_MAJOR</span><span class="p">,</span> <span class="n">DEVICE_NAME</span><span class="p">);</span> 
<span class="p">}</span>
 
<span class="c1">//  AD5420 can not read, so we let it empty
</span><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ad5420_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                           <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span><span class="n">loff_t</span> <span class="o">*</span><span class="n">f_ops</span><span class="p">)</span>
<span class="p">{</span>       
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
 
<span class="c1">// output all values in the daisy-chain
</span><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ad5420_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span><span class="n">loff_t</span> <span class="o">*</span><span class="n">f_ops</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_value</span><span class="p">;</span>
 
    <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">LATCH_PIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
    <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SCLK_PIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
    <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DEVICE_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current_value</span> <span class="o">=</span> <span class="n">global_value_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">WriteUnit</span><span class="p">(</span><span class="n">current_value</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="n">OutPutData</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad5420_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
                  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span>     <span class="n">device_index_</span><span class="p">;</span>
    <span class="k">struct</span>  <span class="n">data_unit</span>  <span class="n">current_unit</span><span class="p">;</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_unit</span><span class="p">,(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">current_unit</span><span class="p">))</span> 
        <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">"copy_from_user failed </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">device_index_</span> <span class="o">=</span>  <span class="n">current_unit</span><span class="p">.</span><span class="n">device_index</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">device_index_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">device_index_</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAX_DEVICE_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">"device index should between [0,5] </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">global_value_array</span><span class="p">[</span><span class="n">device_index_</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_unit</span><span class="p">.</span><span class="n">out_value</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="c1">// learn the write mode timing diagram from the datasheet
</span><span class="kt">void</span> <span class="nf">ShiftCommand</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command_flag</span><span class="p">;</span>
 
    <span class="n">command_</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CMD_BIT_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">command_flag</span> <span class="o">=</span> <span class="n">command_</span> <span class="o">&amp;</span>  <span class="mh">0x80</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">command_flag</span><span class="p">)</span>
            <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SDIN_PIN</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>                 
        <span class="k">else</span>
            <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SDIN_PIN</span> <span class="p">,</span><span class="mi">1</span><span class="p">);</span>                 
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
        <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SCLK_PIN</span> <span class="p">,</span><span class="mi">1</span><span class="p">);</span>    
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
        <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SCLK_PIN</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>    
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
        <span class="n">command_</span>   <span class="o">=</span>   <span class="n">command_</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">ShiftData</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_flag</span><span class="p">;</span>
 
    <span class="n">data_</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DATA_BIT_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data_flag</span> <span class="o">=</span> <span class="n">data_</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">data_flag</span><span class="p">)</span>
            <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SDIN_PIN</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>                 
        <span class="k">else</span>
            <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SDIN_PIN</span> <span class="p">,</span><span class="mi">1</span><span class="p">);</span>                 
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
        <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SCLK_PIN</span> <span class="p">,</span><span class="mi">1</span><span class="p">);</span>    
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
        <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SCLK_PIN</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>    
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
        <span class="n">data_</span> <span class="o">=</span> <span class="n">data_</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">OutPutData</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SDIN_PIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
    <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SCLK_PIN</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>   
    <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">LATCH_PIN</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>   
    <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
    <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">LATCH_PIN</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>   
<span class="p">}</span>
 
<span class="kt">void</span>   <span class="nf">InitDevice</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">data</span><span class="p">;</span>
 
    <span class="c1">// reset, see the chip's datasheet
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DEVICE_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">LATCH_PIN</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>   
        <span class="n">gpio_set_value</span><span class="p">(</span><span class="n">SCLK_PIN</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>   
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span>
 
        <span class="n">command</span> <span class="o">=</span> <span class="mh">0x56</span><span class="p">;</span>   
        <span class="n">ShiftCommand</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
 
        <span class="n">data</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">;</span>
        <span class="n">ShiftData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
 
        <span class="c1">// nop
</span>        <span class="n">command</span> <span class="o">=</span>  <span class="mh">0x00</span><span class="p">;</span> 
        <span class="n">ShiftCommand</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
 
        <span class="n">data</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>  
        <span class="n">ShiftData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
 
        <span class="n">OutPutData</span><span class="p">();</span>
 
        <span class="n">ndelay</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">void</span>   <span class="nf">WriteUnit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">;</span>
    <span class="n">command</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
    <span class="n">ShiftCommand</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
    <span class="n">ShiftData</span><span class="p">(</span><span class="n">out_value</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"AD5420 driver"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"hlding"</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>In order to use our device driver, we should run these two commands:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="n">insmod</span> <span class="n">AD5420</span><span class="p">.</span><span class="n">ko</span>
<span class="n">mknod</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">myAD5420</span> <span class="n">c</span> <span class="mi">253</span> <span class="mi">0</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>And here is our test program:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre></td><td class="code"><pre><span class="cp">#include    &lt;stdio.h&gt;
#include    &lt;fcntl.h&gt;
#include    &lt;unistd.h&gt;
#include    &lt;sys/ioctl.h&gt;
#include    &lt;linux/types.h&gt;
</span> 
<span class="cp">#define MAX_DEVICE_NUM 6 // 6 AD5420 chips in the daisy-chain mode
#define DEVICE_NAME "/dev/myAD5420" // the name of the device
#define SET_CHANNEL_DATA 1
</span> 
<span class="k">struct</span> <span class="n">data_unit</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">device_index</span><span class="p">;</span> <span class="c1">// between [0,MAX_DEVICE_NUM-1]
</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_value</span><span class="p">;</span>     <span class="c1">// 12 bits valid
</span><span class="p">};</span>
 
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">test_value_array</span><span class="p">[</span><span class="n">MAX_DEVICE_NUM</span><span class="p">]</span><span class="o">=</span> <span class="p">{</span><span class="mh">0x7f</span><span class="p">,</span><span class="mh">0x7f</span><span class="p">,</span><span class="mh">0x7f</span><span class="p">,</span><span class="mh">0x7f</span><span class="p">,</span><span class="mh">0x7f</span><span class="p">,</span><span class="mh">0x7f</span><span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">data_unit</span> <span class="n">current_unit</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">device_handle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 
    <span class="c1">// open the device handle
</span>    <span class="n">device_handle</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">DEVICE_NAME</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">device_handle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"open the device failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="c1">// prepare data
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DEVICE_NUM</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current_unit</span><span class="p">.</span><span class="n">device_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">current_unit</span><span class="p">.</span><span class="n">out_value</span> <span class="o">=</span> <span class="n">test_value_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">device_handle</span><span class="p">,</span> <span class="n">SET_CHANNEL_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current_unit</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"ioctl failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">device_handle</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="c1">// output
</span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">device_handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
 
    <span class="c1">// close the device handle
</span>    <span class="n">close</span><span class="p">(</span><span class="n">device_handle</span><span class="p">);</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>References</p>

<p>1) OMAP-L138 C6000 DSP+ARM Processor Technical Reference Manual  <br />
http://www.ti.com/lit/ug/spruh77b/spruh77b.pdf</p>

<p>2) AD5410_5420 datasheet  <br />
http://www.analog.com/media/en/technical-documentation/data-sheets/AD5410_5420.pdf</p>

<p>3) OMAP-L138 Software Design Guide   <br />
http://processors.wiki.ti.com/index.php/OMAP-L138_Software_Design_Guide#Linux_Drivers:</p>

<p>4) Linux Kernel and Driver Development Training   <br />
http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf</p>


    

</div>


    <footer class="site-footer">
    Hailong's homepage<br />

    Using <a href="http://jekyllrb.com/">Jekyll</a>
    
    
</footer>


    

    </div>
  </body>

</html>
